我把**所有与 Unit Testing（单元测试）相关的内容与要求**从你给到的多份讲义中**系统梳理**出来，合并去重，并按“概念 → 方法 → 实操 → 交付与标准”的顺序组织。直接拿去做测试计划就行了。

* * *

一、单元测试的定义与目标
============

*   **定义**：单元测试“在基本**隔离**的条件下测试一个方法（或最小可合理隔离的代码单元）”。
*   **方法在测（method under test）**：由测试框架的 runner/driver 直接调用。
*   **隔离原则**：该方法会调用的“其他代码/外部依赖”用\*\*测试替身（test doubles）\*\*替换。
*   **不要替换标准库**：I/O、math、string 等标准库**不替换**（重写成本高、质量高、可靠性强）。
*   **失败定位**：若测试失败，应尽量定位在“被测单元”而非“遥远依赖”。

* * *

二、为什么要用测试替身（Test Doubles）
=========================

*   **速度**：避免网络/DB/文件系统导致慢测试；每次提交都要快速反馈。
*   **确定性**：屏蔽天气/股价等外部波动，减少 flakiness。
*   **避免副作用/成本**：别发真邮件、真扣款、真付费 API。
*   **搭建复杂度**：避免依赖专用硬件/环境（如“汽车仪表盘”）。
*   **可控性**：可稳定复现极端/罕见场景（磁盘已满、超时、重试等）。

* * *

三、测试替身的术语与类型（统一口径）
==================

> “很多人把所有替身都叫 mock，但 **mock 只是其中一种**。”

*   **Dummy**（占位）：只为让签名通过，**不被使用**、不被断言。
*   **Stub**（桩）：实现接口并返回**硬编码的固定值**，用来**强行走分支**或抛异常/超时。
*   **Mock**（模拟）：用于**行为验证**，记录调用次数、参数、**顺序**，可对顺序/状态作约束。
*   **Fake**（伪实现）：**可工作的简化实现**（常内存版 DB/FS/网络），便于**状态验证**；复杂度较高，通常要给 fake 自己也写测试。
*   **Spy**（间谍）：“**Fake + Mock**”——保留真实行为/状态，同时**记录交互**，既做状态也做行为验证。

* * *

四、验证方式（写断言时你要选哪种）
=================

*   **输出验证（Output verification）**：断言返回值/输出。
*   **行为验证（Behavior verification）**：断言与依赖的**交互**（调用了谁、次数、参数、顺序）。
*   **状态验证（State verification）**：对 **fake** 的内部状态/持久化结果做断言。

* * *

五、单元测试 vs. 类测试 vs. 集成测试（边界清晰）
=============================

*   **单元测试**：最小粒度，**对外依赖替身化**。
*   **类测试（Class testing）**：把一个类当“模块”整体测试：
    *   **类内部**的方法互相调用用**真实现**（不打桩）；
    *   **类外部**依赖仍然用**替身**。
    *   目标：发现**类内方法交互**的缺陷。强调**依赖覆盖**（见下面）。
*   **集成测试**：跨类/跨服务的真实集成。

* * *

六、测试数据设计：输入选择策略
===============

*   **至少覆盖**：
    *   典型有效（Typical valid）
    *   **非典型有效**（边界/角落、少见但允许）
    *   **无效**（应当报错/拒绝）
*   **等价类划分 & 边界值分析**：
    *   为每个等价类挑代表；边界要测**边界值**以及**边界外一格**。
    *   注意语言/UI双重边界（如 UI 有 8 位数字上限 ≠ 语言的 int 上限）。
*   **循环覆盖**：0（若可）、1、2、“多次”，以及定义的最大值。
*   **输入不仅来自形参**：还可能来自**全局状态/系统调用/用户输入** → 用 **mock** 控制它们。
*   **结构化输入（容器/图/树）**：考虑有/无元素、重复、顺序/有序性、不变式、极端大小等。

* * *

七、覆盖与路径：不止是语句/分支
================

*   **分支覆盖**：每个 `if/else` 的真/假都要走到。
*   **循环覆盖**：见上。
*   **“缺失的 else”**：常见漏测；要断言条件为 **false** 的路径。
*   **依赖覆盖（类测试强调）**：不仅要 statement/branch，还要确保**类内各方法之间的调用关系**都被触达；多个单测若触达相同内部依赖则对“依赖覆盖”而言是冗余。
*   **白盒推导**：**反向**设计输入以满足特定路径/到达特定内部调用点。

* * *

八、测试结构与风格
=========

*   **命名**：短小明确，如 `test_single_occurrence_replace`。
*   **组织风格**：
    *   **AAA** = Arrange / Act / Assert
    *   **GWT** = Given / When / Then（与 AAA 一一对应）
*   **断言优先**：别用 `print` 当测试；需要自动判定通过/失败。

* * *

九、测试夹具（Fixtures）与生命周期
=====================

*   **目标**：提供**固定、可预测、可重复**的环境。
*   **生命周期注解**（名称因框架而异）：
    *   `BeforeAll / AfterAll`：组级一次，适合**共享昂贵资源**。
    *   `BeforeEach / AfterEach`：**每个测试**一套新实例，防共享状态串扰。
    *   `Timeout`：防止挂死（适合外部资源或意外死循环）。
    *   `Disabled`：临时跳过。
*   **资源管理差异**：
    *   Java：释放引用便于 GC。
    *   C/C++：必须手动释放避免泄漏。

* * *

十、运行与独立性：顺序/并发/可靠性
==================

*   **随机顺序或并行执行**是常态：**避免测试间相互依赖**。
*   **有意的组内顺序**：在\*\*同一组（test class）\*\*中可设计顺序性，但组与组之间要独立。
*   **并发/竞态**：共享可变状态 + 并行会出竞态 → 用 `BeforeEach` 彻底隔离，必要时串行化组内相关测试。

* * *

十一、CI 流程中的单元测试（课内要求）
====================

*   **CI（持续集成）而非夜构**：**每次合并/提交**触发构建+测试（使用 GitHub Actions）。
*   **小步提交 → 快速反馈**：减少“集成地狱”。
*   **测试应为“按钮式”一键运行**：脚本/命令/CI job 明确。

* * *

十二、课程交付与量化标准（来自多次课堂说明）
======================

*   **团队项目 Iteration 2**：**覆盖率 ≥ 80%**（90% 更好）。
*   **Mini-project**：目标是**逐步提高覆盖率**；只加代码不加测试会**拉低百分比**。
*   **README 要有 “Testing” 说明**：工具、如何运行、配置位置。
*   **测试目录结构清晰**：体现**分组**与**夹具**。
*   **PR 关联 bug 修复**：把单测发现并修复的问题在 PR 中说明。

* * *

十三、Staging vs Production（与单元测试边界相关）
===================================

*   **Staging**：用于端到端/系统级测试，**真代码 + 假数据**，多节点多服务。
*   **Production**：不要跑测试；用**监控**发现问题。
*   单元测试发生在**本地/CI**，不依赖真实外部系统。

* * *

十四、典型示例清单（来自“Search & Replace”案例）
=================================

> 这些都应写成单测（或伪装成类测试时保留类内真实交互、对外替身）。

1.  **基础行为**
    *   单次匹配、多个匹配。
    *   **整词** vs **部分词**：整词时 `dog` 不应匹配 `dog-along`；部分词时应匹配。
2.  **大小写选项**
    *   区分大小写：仅精确大小写替换。
    *   忽略大小写：`dog/Dog/DOG` 都匹配。
3.  **替换长度变化**
    *   更长/更短/空字符串（删除）；删除后空格可能变双空格——**不自动修空格**。
    *   “未找到”应不改变文本。
4.  **位置/重叠**
    *   文首/文末、相邻匹配（如 `catcatcat`）、重复序列。
    *   整词模式下 `concatenate` 不匹配 `cat`。
5.  **非常规但有效输入**
    *   非 ASCII/重音（`Bistró → Cafe`）
    *   含标点的匹配目标（省略号、引号、分号等）。

* * *

十五、常见陷阱与老师特别提醒
==============

*   只测 `if` 的“真”分支，**漏测 else**。
*   测试间共享状态导致**顺序耦合**与**并发竞态**。
*   用 `print` 代替断言。
*   过度打桩：**类内**互调在类测试中应用**真实现**，否则测不到交互缺陷。
*   **过度替换标准库**（不必要也不现实）。
*   假定 UI/语言边界一致（实际上常不同）。

* * *

十六、实施清单（落地即用）
=============

**测试设计**

*    为每个单元列出：**典型有效 / 非典型有效 / 无效**用例。
*    做**等价类**与**边界值**拆分；循环 0/1/2/多。
*    明确**输出/行为/状态**三类验证方式。
*    对**外部依赖**选择合适的替身：Dummy/Stub/Mock/Fake/Spy。
*    为 **Fake** 自身补上单测（尤其是内存版 DB/FS）。

**工程化**

*    夹具 `BeforeAll/Each` 合理使用；避免测试间状态串扰。
*    为易挂操作加 `Timeout`；必要时 `Disabled`。
*    测试命名采用 `AAA`/`GWT` 风格；名称清晰可读。
*    本地一键命令 + CI Job（GitHub Actions）跑全套。
*    输出覆盖率报告；追踪缺口至具体文件/分支。

**课程交付**

*    README 的 **“Testing”** 章节：工具栈、运行方法、配置。
*    提交结构清晰的测试树，体现分组与夹具。
*    PR 中引用由测试发现并修复的缺陷。
*     覆盖率 **≥ 80%**（力争更高）。

* * *

严格按照 Unit Testing（单元测试）相关的内容与要求完成这个项目的unit testing 先从这次的功能入手 

力求增加覆盖率

力求增加覆盖率
test需要分文件 格式规范 更加清晰 class上需要有javadoc 英文注释。测试之后mvn clean install pmd and checkstyle
  注意不是蛮力写测试 你是需要先分析缺少什么case 导致覆盖率没上来。我追求覆盖率