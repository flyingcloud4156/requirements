我把你给的所有讲义/笔记里，与“## 6. API (System) Testing”有关的要点都**汇总、去重、补全上下文**，并整理成「目标—范围—方法—工具—产出—验收—常见坑—示例」八部分，最后附一页执行清单与样板文档结构，拿来就能用。

一、目标（为什么要做 API/System 测试）
=========================

*   **验证服务从系统边界看起来是对的**：请求/响应、状态码、持久化副作用、跨组件/方法的交互是否满足用例与验收标准（GWT）。
*   **支撑持续集成**：每次合并即构建+测试，避免“集成地狱”。
*   **发现单元测试找不到的问题**：缺失功能、接口契约不一致、持久化/日志缺失、幂等性与重试语义。
*   **在可控环境下验证异常路径**：通过**测试替身/虚拟服务**稳定制造失败场景。

二、测试范围与深度
=========

*   **系统入口**：覆盖你服务对外暴露的**全部 API 端点**（REST/gRPC 均可），含必选与可选参数、鉴权路径。
*   **数据持久化**：写入、读取、更新、删除（CRUD），**重启后仍在**。
*   **日志**：每个入口调用都应有**结构化日志**（时间戳、请求ID、客户端ID/Token、参数摘要、结果、时延、错误）。
*   **多客户端隔离**：至少两类或两租户，验证**互不干扰**。
*   **幂等性/重试**：对于应幂等的操作，验证**重复请求不产生重复副作用**；对非幂等操作，定义并验证**拒绝重复**或**去重策略**。
*   **时序/一致性**：必要时检查**顺序/版本冲突**（If-Match/版本号）。
*   **性能基本线**：不是压测，但要有**超时/Deadline**与响应时间上限（客户端/服务端均定义）。

三、测试方法（怎么测）
===========

1.  **测试设计原则**
    *   **典型有效 + 非典型有效 + 无效**三类；用**等价类与边界值**减少用例数量、提高杀伤力。
    *   **行为验证 + 状态验证 + 输出验证**三位一体：
        *   输出：响应体/状态码。
        *   行为：是否调用了某依赖（顺序/次数/参数）。
        *   状态：DB/缓存/文件系统/日志的最终状态。
2.  **系统级替身（API Test Doubles）**
    *   客户端侧：用**虚拟服务**替代下游（WireMock、Mockoon、VCR、gRPC mock）。
    *   服务器侧：为需要回调的场景准备**客户端回调替身**。
    *   目的：**快、可重复、可控制**（超时、限流、乱序、错误码）。
3.  **环境分层**
    *   **单元测试**：方法级，几乎全替身。
    *   **类测试**：类内部调用用真实现；类外依赖仍用替身。
    *   **系统/API 测试**（本节）：服务整体对外接口，**真代码 + 虚拟外部世界**。
    *   **Staging**：真代码 + 假数据，跨服务端到端验证；**不要在生产上跑测试**，生产用**监控**。
4.  **CI 集成**
    *   每个 PR 触发：构建 → 启动服务（本地/容器）→ 运行 API 测试 → 收集报告与样例日志。
    *   避免夜间批量才测；小步快跑。

四、工具与工件
=======

*   **API 测试**：Postman/Thunder Client/Insomnia（可导出/共享工作区），或 k6（冒烟/简单基准）。
*   **Mock/虚拟服务**：WireMock、Mockoon、gRPC mock、VCR（HTTP录制）。
*   **日志**：真实日志库，分级（DEBUG/INFO/WARN/ERROR/CRITICAL），持久化+轮转，PII/Secrets 遮蔽。
*   **CI**：GitHub Actions（课程推荐），流水线生成**测试报告与工件**（日志片段、环境配置）。

五、明确产出（提交物）
===========

> 这些在你给的笔记后半段“**Evidence to provide**”已写明，这里按可交付格式细化。

1.  **API 测试工作区**（必须）
    *   Postman/Thunder/Insomnia **导出文件**（版本控制进仓库）或**共享链接**（README 链接）。
    *   每个端点≥3条测试：典型有效、非典型有效、无效。
2.  **运行说明**
    *   README 中“如何启动服务并运行 API 测试”的**一键脚本/命令**与先决条件。
3.  **持久化证明**
    *   用例至少包含一次**写入**，以及随后在**新请求/重启后读取验证**。
4.  **日志证明**
    *   附**样例日志**（敏感字段打码），能看到：入口、参数摘要、调用方、结果、错误与时延。
5.  **多客户端隔离证明**
    *   两个不同客户端/租户的用例与**隔离断言**。
6.  **替身配置**
    *   WireMock/Mockoon 配置或 gRPC mock 脚本，能复现**超时/错误/顺序**等场景。
7.  **错误分类表（Error Taxonomy）**
    *   列出本服务可能返回的状态码/错误码/错误字段结构与**触发条件**。

六、验收标准（你可以用这套自测）
================

*   **覆盖**：所有公开端点均有测试，且每端点覆盖「典型/非典型/无效」。
*   **契约一致**：请求/响应 Schema、状态码、错误字段与 API 文档一致（含字段类型与必填）。
*   **副作用明确**：每个有副作用的端点，都有**状态验证**（DB/缓存/文件/日志）。
*   **日志完备**：每次 API 调用均可在日志中按请求ID串起（入参摘要→结果/错误→耗时）。
*   **幂等性**：声明幂等的操作，**重复调用不重复生效**；不幂等的操作，有拒绝/去重策略并测试。
*   **时限与超时**：客户端/服务端 Deadline 均被测试（超时返回一致、无“幽灵写入”）。
*   **数据隔离**：多客户端数据不串。
*   **重启健壮性**：重启后数据仍在；写入与提交点清晰（无中间态泄露）。
*   **可复现性**：虚拟服务脚本保证失败场景**稳定复现**。

七、常见踩坑与规避
=========

*   **只断言响应，不断言状态/日志** → 漏掉“写错地方”“没记日志”等缺陷。
*   **把外部依赖当真依赖测** → 慢又不稳定；请用虚拟服务。
*   **测试数据相互污染** → 用 BeforeEach/随机化租户/隔离库或前后清理。
*   **状态码随意**：把所有错误都返回 400/500；应区分 401/403/404/409/422/429 等。
*   **没有幂等语义**：支付/库存等重复请求导致重复扣减。
*   **日志泄露敏感信息**：token/PII 未遮蔽。
*   **仅夜间跑**：与课程“CI”思想相悖，PR 未经测试就合并。

八、示例（可直接照抄改名）
=============

1) Postman/Thunder 用例命名规范
-------------------------

```
<资源>/<操作> — <用例类型>
例如：
orders/create — valid_typical
orders/create — invalid_conflict_duplicateId
orders/get — atypical_largePayload
auth/login — invalid_wrongPassword
```

2) 错误分类（片段示例）
-------------

*   400 Bad Request：JSON 结构错误/必填缺失/类型不符
*   401 Unauthorized：缺失/非法 Token
*   403 Forbidden：Token 有效但权限不足
*   404 Not Found：资源不存在或不属于该租户
*   409 Conflict：版本冲突/重复请求（非幂等操作）
*   422 Unprocessable Entity：业务校验失败（如库存不足）
*   429 Too Many Requests：限流
*   500/502/503：服务器/下游不可用（配合重试/退避策略）

**错误响应结构（建议）**

```json
{
  "error": {
    "code": "CONFLICT",
    "httpStatus": 409,
    "message": "Order version conflict",
    "requestId": "…",
    "details": {"expectedVersion": 3, "actualVersion": 2}
  }
}
```

3) 幂等请求示例
---------

*   Header：`Idempotency-Key: <uuid>`
*   测试步骤：
    1.  首次 `POST /payments`（200 成功，落库一条记录，日志有该请求ID）。
    2.  2 秒内**重复同键**再发（200/201 + **同一结果**，**不新增记录**）。
    3.  移除键重复发（若定义为非幂等 → 409/拒绝）。

4) 日志样例核对项（断言点）
---------------

*   `ts`、`level`、`requestId`、`clientId`、`endpoint`、`status`、`latencyMs`
*   入参只记录**摘要/哈希**；Token/PII 已遮蔽。

* * *

一页执行清单（Checklist）
=================

*    列出**所有 API 入口**；每个 ≥3 个用例（典型/非典型/无效）。
*    搭好**虚拟外部依赖**（WireMock/Mockoon/gRPC mock/VCR）。
*    准备**多客户端/租户数据**；断言相互隔离。
*    设计并验证**幂等/重试**语义与冲突处理。
*    用例包含**写→读**，并在**服务重启后**再次读验证。
*    断言**日志**齐全且合规（无敏感泄露）。
*    CI：PR 触发构建+启动+跑 API 测试+产出报告与日志样例工件。
*    README：一键运行说明；附工作区导出与日志样例。
*    错误分类与状态码对齐 API 文档；无 200 含错/吞错现象。
*    记录并修复由 API 测试发现的**主要缺陷**，在报告中标注。

* * *

交付结构样板（放进仓库）
============

```
/api-tests/
  postman_collection.json
  postman_environment.json
  wiremock/
    mappings/*.json
    __files/*.json
  grpc-mocks/…
/docs/
  api-contract.md        # OpenAPI 或 protobuf 契约链接/片段
  error-taxonomy.md      # 错误分类与示例
  logging-samples.md     # 样例日志（脱敏）
README.md                # 启动与运行测试的说明（含一键命令）
.github/workflows/ci.yml # 构建+启动+跑测试+上传工件
```

如果你愿意，我可以把上面的**Postman 集合骨架、WireMock 映射示例、GitHub Actions 工作流**按你的端点名直接生成一套初稿，省你搭骨架的时间。



---
Powered by [ChatGPT Exporter](https://www.chatgptexporter.com)